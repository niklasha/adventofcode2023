use crate::day::*;
use std::cmp::Ordering;

pub struct Day07 {}

type Output = usize;

impl Day for Day07 {
    fn tag(&self) -> &str {
        "07"
    }

    fn part1(&self, input: &dyn Fn() -> Box<dyn io::Read>) {
        println!("{:?}", self.part1_impl(&mut *input()));
    }

    fn part2(&self, input: &dyn Fn() -> Box<dyn io::Read>) {
        println!("{:?}", self.part2_impl(&mut *input()));
    }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
enum Card {
    A,
    K,
    Q,
    J,
    T,
    P9,
    P8,
    P7,
    P6,
    P5,
    P4,
    P3,
    P2,
}

impl Card {
    fn from(face: char) -> BoxResult<Self> {
        Ok(match face {
            'A' => Card::A,
            'K' => Card::K,
            'Q' => Card::Q,
            'J' => Card::J,
            'T' => Card::T,
            '9' => Card::P9,
            '8' => Card::P8,
            '7' => Card::P7,
            '6' => Card::P6,
            '5' => Card::P5,
            '4' => Card::P4,
            '3' => Card::P3,
            '2' => Card::P2,
            _ => Err(AocError)?,
        })
    }

    fn face(&self) -> char {
        match self {
            Card::A => 'A',
            Card::K => 'K',
            Card::Q => 'Q',
            Card::J => 'J',
            Card::T => 'T',
            Card::P9 => '9',
            Card::P8 => '8',
            Card::P7 => '7',
            Card::P6 => '6',
            Card::P5 => '5',
            Card::P4 => '4',
            Card::P3 => '3',
            Card::P2 => '2',
        }
    }

    fn cmp2(&self, other: &Self) -> Ordering {
        if *self == Card::J {
            if *other == Card::J {
                Ordering::Equal
            } else {
                Ordering::Greater
            }
        } else if *other == Card::J {
            Ordering::Less
        } else {
            self.cmp(other)
        }
    }
}

#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
enum Type {
    FiveOfAKind,
    FourOfAKind,
    FullHouse,
    ThreeOfAKind,
    TwoPair,
    OnePair,
    HighCard,
}

#[derive(Debug, Eq, PartialEq)]
struct Hand {
    cards: [Card; 5],
}

impl Hand {
    fn from(s: &str) -> BoxResult<Self> {
        Ok(Hand {
            cards: s
                .chars()
                .map(Card::from)
                .collect::<BoxResult<Vec<_>>>()?
                .try_into()
                .map_err(|_| AocError)?,
        })
    }

    fn get_type(&self) -> Type {
        let groups = self.cards.iter().counts_by(|card| card);
        match groups.len() {
            1 => Type::FiveOfAKind,
            2 => groups
                .into_values()
                .find(|&count| count == 1)
                .map_or(Type::FullHouse, |_| Type::FourOfAKind),
            3 => groups
                .into_values()
                .find(|&count| count == 2)
                .map_or(Type::ThreeOfAKind, |_| Type::TwoPair),
            4 => Type::OnePair,
            5 => Type::HighCard,
            _ => unreachable!(),
        }
    }

    fn get_type2(&self) -> Type {
        let builder = self.cards.iter().map(|card| {
            if *card == Card::J {
                vec![
                    Card::A,
                    Card::K,
                    Card::Q,
                    Card::T,
                    Card::P9,
                    Card::P8,
                    Card::P7,
                    Card::P6,
                    Card::P5,
                    Card::P4,
                    Card::P3,
                    Card::P2,
                ]
            } else {
                vec![*card]
            }
        });
        let hands = builder
            .fold(vec![Vec::new()], |mut hands, cards| {
                if cards.len() == 1 {
                    hands.iter_mut().for_each(|hand| hand.push(cards[0]));
                } else {
                    hands = cards
                        .into_iter()
                        .flat_map(|card| {
                            hands.iter().map(move |hand| {
                                let mut new_hand = hand.clone();
                                new_hand.push(card);
                                new_hand
                            })
                        })
                        .collect();
                };
                hands
            })
            .iter()
            // Proof of safety:
            // This unwrap is safe if the Hand::from function always successfully converts a valid hand string into a
            // Hand object. The safety hinges on the assurance that the string generated by
            // v.iter().map(|card| card.face()).collect::<String>() is always a valid hand representation. Since this
            // string is constructed from a vector of Card enums (which are valid by definition), the resulting string
            // is guaranteed to be a valid hand. Hence, the unwrap is safe.
            .map(|v| Hand::from(&v.iter().map(|card| card.face()).collect::<String>()).unwrap())
            .collect_vec();
        // Proof of safety:
        // Here, the unwrap is applied to the result of min(), which can return None if the iterator is empty. However,
        // this iterator is generated from a non-empty collection of hands (hands vector). Since we're operating on a
        // collection derived from valid Hand objects, it's guaranteed to contain at least one element, making
        // min().unwrap() safe.
        let rv = hands.iter().map(|hand| hand.get_type()).min().unwrap();
        rv
    }

    fn cmp2(&self, other: &Self) -> Ordering {
        match self.get_type2().cmp(&other.get_type2()) {
            Ordering::Equal => self
                .cards
                .iter()
                .zip(other.cards.iter())
                .map(|(a, b)| a.cmp2(b))
                .find(|&o| o != Ordering::Equal)
                .unwrap_or(Ordering::Equal),
            ordering => ordering,
        }
    }
}

impl PartialOrd<Self> for Hand {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Hand {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.get_type().cmp(&other.get_type()) {
            Ordering::Equal => self
                .cards
                .iter()
                .zip(other.cards.iter())
                .map(|(a, b)| a.cmp(b))
                .find(|&o| o != Ordering::Equal)
                .unwrap_or(Ordering::Equal),
            ordering => ordering,
        }
    }
}

#[derive(Debug)]
struct Bid {
    hand: Hand,
    amount: Output,
}

impl Bid {
    fn from(s: &str) -> BoxResult<Self> {
        let [cards, bid] = s
            .split_whitespace()
            .collect::<Vec<_>>()
            .try_into()
            .map_err(|_| AocError)?;
        Ok(Bid {
            hand: Hand::from(cards)?,
            amount: bid.parse()?,
        })
    }

    fn cmp2(&self, other: &Self) -> Ordering {
        self.hand.cmp2(&other.hand)
    }
}

impl Eq for Bid {}

impl PartialEq<Self> for Bid {
    fn eq(&self, other: &Self) -> bool {
        self.hand == other.hand
    }
}

impl PartialOrd<Self> for Bid {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Bid {
    fn cmp(&self, other: &Self) -> Ordering {
        self.hand.cmp(&other.hand)
    }
}

impl Day07 {
    fn parse(input: &mut dyn io::Read) -> BoxResult<Vec<Bid>> {
        io::BufReader::new(input)
            .lines()
            .map(|rs| rs.map_err(|e| e.into()).and_then(|s| Bid::from(&s)))
            .collect::<BoxResult<Vec<_>>>()
    }

    fn part1_impl(&self, input: &mut dyn io::Read) -> BoxResult<Output> {
        let mut game = Self::parse(input)?;
        game.sort();
        game.reverse();
        Ok(game
            .into_iter()
            .enumerate()
            .map(|(i, bid)| (i + 1) * bid.amount)
            .sum())
    }

    fn part2_impl(&self, input: &mut dyn io::Read) -> BoxResult<Output> {
        let mut game = Self::parse(input)?;
        game.sort_by(Bid::cmp2);
        game.reverse();
        Ok(game
            .into_iter()
            .enumerate()
            .map(|(i, bid)| (i + 1) * bid.amount)
            .sum())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test1(s: &str, f: Output) {
        assert_eq!(Day07 {}.part1_impl(&mut s.as_bytes()).ok(), Some(f));
    }

    #[test]
    fn part1() {
        test1(
            "32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483",
            6440,
        );
    }

    fn test2(s: &str, f: Output) {
        assert_eq!(Day07 {}.part2_impl(&mut s.as_bytes()).ok(), Some(f));
    }

    #[test]
    fn part2() {
        test2(
            "32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483",
            5905,
        );
    }
}
